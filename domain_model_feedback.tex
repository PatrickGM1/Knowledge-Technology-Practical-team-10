\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage{hyperref}

% Python code styling
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python
}

\lstdefinestyle{yamlstyle}{
    backgroundcolor=\color{backcolour},   
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    keepspaces=true,
    numbers=left,
    numbersep=5pt
}

\lstset{style=pythonstyle}

\title{Domain Model Restructuring\\Recipe Recommender System}
\author{Team 10 - Knowledge Technology Practical}
\date{January 9, 2026}

\begin{document}

\maketitle

\section{Professor's Feedback}

\textit{``You seem to be confusing classes in the domain model with programming classes. While a class in this sense can be represented by an OOP class, enum classes do not have the same function. You seem to be confusing the two.''}

\vspace{0.5em}

\textbf{Advice:} Add more actual classes. E.g., \texttt{Person} with items such as allergy, budget, etc. \texttt{Kitchen} with items such as available utensils, etc. Manipulate the values of these objects with the rules. Then base your final recommendation on the values of these objects.

\section{Current Problem}

We are using \textbf{enums} (\texttt{Diet}, \texttt{Budget}, \texttt{Skill}, etc.) which are programming constructs, not true domain model classes. The professor wants actual \textbf{domain classes} with attributes and behavior.

\section{Proposed Restructure}

\subsection{1. Person/User Class (Enhanced)}

Instead of storing simple strings/enums, we should have rich domain objects:

\begin{lstlisting}[style=pythonstyle]
class Person:
    name: str
    allergies: List[Allergy]  # Not List[str]
    budget: BudgetConstraint  # Not enum
    skill: CookingSkill       # Not string/enum
    time_constraint: TimeConstraint
    dietary_preference: DietaryPreference
    health_goals: List[HealthGoal]
\end{lstlisting}

\subsection{2. Kitchen Class (New Domain Class)}

Represents the cooking environment:

\begin{lstlisting}[style=pythonstyle]
class Kitchen:
    available_equipment: List[Equipment]
    available_utensils: List[Utensil]
    storage_items: List[Ingredient]
    space_size: str
    
    # Methods
    def can_prepare(self, recipe) -> bool:
        """Check if kitchen has necessary equipment"""
        pass
        
    def has_equipment(self, equipment_name: str) -> bool:
        """Check if specific equipment is available"""
        pass
\end{lstlisting}

\subsection{3. Supporting Domain Classes (Instead of Enums)}

\subsubsection{Allergy Class}

\begin{lstlisting}[style=pythonstyle]
class Allergy:
    allergen_name: str
    severity: str  # mild, moderate, severe
    ingredients_to_avoid: List[str]
    
    def is_safe(self, ingredient: Ingredient) -> bool:
        """Check if ingredient is safe for this allergy"""
        return ingredient.name not in self.ingredients_to_avoid
\end{lstlisting}

\subsubsection{BudgetConstraint Class}

\begin{lstlisting}[style=pythonstyle]
class BudgetConstraint:
    min_cost: float
    max_cost: float
    preferred_range: str
    flexibility: str  # strict, flexible, very_flexible
    
    def can_afford(self, recipe: Recipe) -> bool:
        """Check if recipe fits within budget"""
        return self.min_cost <= recipe.cost <= self.max_cost
\end{lstlisting}

\subsubsection{CookingSkill Class}

\begin{lstlisting}[style=pythonstyle]
class CookingSkill:
    level: str  # beginner/intermediate/advanced
    years_experience: int
    comfortable_techniques: List[str]
    learned_recipes: List[str]
    
    def can_handle(self, recipe_complexity: str) -> bool:
        """Check if skill level matches recipe complexity"""
        skill_order = ['beginner', 'intermediate', 'advanced']
        return (skill_order.index(self.level) >= 
                skill_order.index(recipe_complexity))
\end{lstlisting}

\subsubsection{TimeConstraint Class}

\begin{lstlisting}[style=pythonstyle]
class TimeConstraint:
    available_minutes: int
    includes_prep: bool
    flexibility: bool
    
    def can_fit(self, recipe: Recipe) -> bool:
        """Check if recipe fits time constraint"""
        total_time = recipe.prep_time + recipe.cook_time
        return total_time <= self.available_minutes
\end{lstlisting}

\subsubsection{DietaryPreference Class}

\begin{lstlisting}[style=pythonstyle]
class DietaryPreference:
    type: str  # vegan, vegetarian, pescatarian, omnivore
    restrictions: List[str]
    preferred_cuisines: List[str]
    
    def is_compatible(self, recipe: Recipe) -> bool:
        """Check if recipe matches dietary preference"""
        return recipe.diet_type == self.type
\end{lstlisting}

\section{How Rules Would Work}

Rules would manipulate object states and attributes:

\begin{lstlisting}[style=yamlstyle]
- rule: check_allergy_compatibility
  conditions:
    - person.allergies exists
    - recipe.ingredients contains allergen
  action:
    - set recipe.suitable_for_user = false
    - add reason to recipe.exclusion_reasons

- rule: check_budget_fit
  conditions:
    - recipe.cost > person.budget.max_cost
  action:
    - set recipe.affordable = false
    
- rule: check_kitchen_capability
  conditions:
    - kitchen.has_equipment(recipe.required_equipment) = false
  action:
    - set recipe.can_prepare = false
    - suggest kitchen.equipment_alternatives
\end{lstlisting}

\section{Final Recommendation Logic}

Instead of filtering lists, we would check object states:

\begin{lstlisting}[style=pythonstyle]
def recommend_recipes(person, kitchen, recipes):
    recommendations = []
    
    for recipe in recipes:
        # Rules modify recipe attributes
        apply_rules(person, kitchen, recipe)
        
        # Check final state
        if (recipe.suitable_for_user and 
            recipe.affordable and 
            recipe.can_prepare and 
            recipe.skill_appropriate):
            recommendations.append(recipe)
    
    return recommendations
\end{lstlisting}

\section{Key Differences}

\begin{table}[h]
\centering
\begin{tabularx}{\textwidth}{|X|X|}
\hline
\textbf{Current (Enums)} & \textbf{Should Be (Domain Classes)} \\
\hline
\texttt{dietary\_restrictions: List[DietRestriction]} & \texttt{dietary\_preference: DietaryPreference} \\
\hline
\texttt{skill\_level: str} & \texttt{skill: CookingSkill} \\
\hline
\texttt{allergies: List[str]} & \texttt{allergies: List[Allergy]} \\
\hline
No Kitchen concept & \texttt{kitchen: Kitchen} with equipment \\
\hline
Rules filter lists & Rules modify object attributes \\
\hline
Simple data storage & Objects with behavior and methods \\
\hline
\end{tabularx}
\caption{Comparison of current and proposed approaches}
\end{table}

\section{Benefits of This Approach}

\begin{itemize}
    \item \textbf{True Object-Oriented Design:} Classes represent real-world concepts with behavior
    \item \textbf{Rich Domain Model:} Objects have meaningful methods, not just data
    \item \textbf{Flexible Rules:} Can manipulate object state instead of just filtering
    \item \textbf{Better Separation:} Domain logic separate from programming constructs
    \item \textbf{Easier Testing:} Can test individual domain class behaviors
    \item \textbf{More Realistic:} Models how things actually work in the real world
\end{itemize}

\section{Implementation Steps}

\begin{enumerate}
    \item Create new domain classes: \texttt{Allergy}, \texttt{BudgetConstraint}, \texttt{CookingSkill}, \texttt{TimeConstraint}, \texttt{DietaryPreference}, \texttt{Kitchen}
    \item Update \texttt{Person} class to use these domain objects
    \item Update \texttt{Recipe} class to have state attributes (\texttt{suitable\_for\_user}, \texttt{affordable}, etc.)
    \item Modify rules to manipulate object attributes instead of filtering
    \item Update recommendation logic to check object states
    \item Update UI to work with domain objects
\end{enumerate}

\end{document}
